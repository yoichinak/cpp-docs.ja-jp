---
description: '詳細情報: アルゴリズム'
title: アルゴリズム
ms.date: 10/18/2018
helpviewer_keywords:
- libraries [C++], C++ algorithm conventions
- algorithms [C++], C++
- C++ Standard Library, algorithms
- algorithm template function C++ library conventions
- conventions [C++], C++ algorithm
ms.assetid: dec9b373-7d5c-46cc-b7d2-21a938ecd0a6
ms.openlocfilehash: b5c053a4ac554685eb4f282db69cc48e99e2212e
ms.sourcegitcommit: d531c567c268b676b44abbc8416ba7e20d22044b
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/16/2021
ms.locfileid: "107539782"
---
# <a name="algorithms"></a>アルゴリズム

アルゴリズムは、C++ 標準ライブラリの基本的な部分です。 アルゴリズムは、コンテナー自体と共に機能するのではありません。反復子と共に機能します。 そのため、C++ 標準ライブラリ コンテナーのすべてではありませんが、そのほとんどで同じアルゴリズムを使用できます。 このセクションでは、C++ 標準ライブラリ アルゴリズムの規則と用語について説明します。

## <a name="remarks"></a>注釈

アルゴリズム テンプレート関数の説明では、いくつかの簡略な語句を使用しています。

- "Range \[ *A*, *B*)" という語句は、0個以上の不連続値のシーケンスを意味します。ここでは、 *b* を含めずに *、1* から始まります。範囲は *、* *b* がから到達可能な場合にのみ有効です。 *a を* オブジェクト *n* (*n*  =  *A*) に格納し、オブジェクトを0回以上インクリメント (+ +*N*) して、有限数のインクリメント (*N* b) の後に *b* と等しいオブジェクトを比較することができ  ==  ます。

- "各 *n* の範囲 \[ *a*, *B*)" は、 *n* が値 *a* で始まり、値 *B* と等しくなるまで0回以上インクリメントされることを意味します。ケース *N*  ==  *B* は範囲内にありません。

- "X" のように "範囲 a, b の最小値 *n* )" という語句は、 \[   条件  \[ *x* が満たされるまで、範囲 *a*, *b*) 内の各 n に対して条件 x が決定されることを意味します。

- "X の範囲内の *n* の最大値 \[ *b*)" という語句は 、a, b の範囲内の各 *N* に対して *x* が決定される *ことを* 意味し \[ ます。  この関数は、条件 *X* が満たされるたびに *N* のコピーを *K* に格納します。 このようなストアが発生した場合、関数は *B* に等しい *N* の最終的な値を *K* の値で置き換えます。ただし、双方向アクセス反復子またはランダムアクセス反復子の場合は、 *N* が範囲内の最大値から始まり、条件 *X* が満たされるまでその範囲でデクリメントされることを意味することもあります。

- *X*  -  *Y* のような式 ( *x* と *y* はランダムアクセス反復子以外の反復子になることがあります) は、数学的な意味を持ちます。 **-** このような値を決定する必要がある場合、関数は必ずしも演算子を評価するとは限りません。 同じことは、 *x* n や x n などの式にも当てはまり  +     -  ます。ここで、 *n* は整数型です。

いくつかのアルゴリズムでは、のようなペアの比較を実行する述語を使用して、 `operator==` 結果を生成 **`bool`** します。 述語関数 `operator==`、または、それに変わる関数では、どちらのオペランドも変更されません。 評価されるたびに同じ結果を生成する必要があり **`bool`** ます。また、いずれかのオペランドのコピーがオペランドとして置き換えられた場合は、同じ結果が生成される必要があります。

いくつかのアルゴリズムでは、厳密弱順序をシーケンスの要素のペアに強制する述語を使用します。 述語 *pred*(*X*, *Y*) の場合:

- Strict は、 *pred*(*x*, *x*) が false であることを意味します。

- Weak は、   \! *pred*(*x*, *y*)  && \! *pred*(*y*, *x*) (*x*  ==  *y* を定義する必要がない) の場合に、x と y の順序が等価であることを意味します。

- 順序付けとは、 *pred*(*x*, *y*)  && *pred*(*y*, *z*) が *pred*(*x*, *z*) を意味することを意味します。

これらのアルゴリズムの一部では、暗黙的に述語 *X* \< *Y*. Other predicates that typically satisfy the strict weak ordering requirement are *X* > *Y*、 `less` (*x*、 *y*)、および `greater` (*x*, *y*) が使用されます。 ただし、 *X* Y などの述語が \<= *Y* and *X* > =  この要件を満たしていないことに注意してください。

範囲内の反復子によって指定された一連の要素 \[ *`First`* *`Last`* ) は、演算子によって順序付けられたシーケンスであり、範囲 **`<`** 0 の各 *N* に対して、 \[ *`Last`*  -  *`First`* (*n*) 範囲内の各 *M* に対して *`Last`*  -  *`First`* 述語 \! ( \* ( *`First`*  +  *M*) < \* ( *`First`*  +  *n*)) が true になります。 (要素は昇順で並べ替えられていることに注意してください)。述語関数 `operator<` 、またはそれに対する置換では、オペランドのいずれかを変更することはできません。 評価されるたびに同じ結果を生成する必要があり **`bool`** ます。また、いずれかのオペランドのコピーがオペランドとして置き換えられた場合は、同じ結果が生成される必要があります。 さらに、比較するオペランドに対して厳密弱順序を適用する必要があります。

範囲内の反復子によって指定された要素のシーケンス \[ `First` `Last` ) は、によって順序付けられたヒープです `operator<` (範囲1の *N* ごとに \[ *`Last`*  -  *`First`* ) \! 。述語 ( \* _最初_  <  \* ( *`First`*  +  *n*)) は true です。 (最初の要素が最大値です)。その内部構造は、テンプレート関数、、およびにのみ認識され [`make_heap`](algorithm-functions.md#make_heap) [`pop_heap`](algorithm-functions.md#pop_heap) [`push_heap`](algorithm-functions.md#push_heap) ます。 順序付けされたシーケンスの場合と同様に、述語関数 `operator<` 、またはそれに対する置換では、オペランドのいずれかを変更することはできません。また、比較するオペランドに厳密弱順序を適用する必要があります。 評価されるたびに同じ結果を生成する必要があり **`bool`** ます。また、いずれかのオペランドのコピーがオペランドとして置き換えられた場合は、同じ結果が生成される必要があります。

C++ 標準ライブラリのアルゴリズムは、 [`<algorithm>`](algorithm.md) [`<numeric>`](numeric.md) ヘッダーファイルとヘッダーファイルにあります。

## <a name="see-also"></a>こちらもご覧ください

[C++ 標準ライブラリリファレンス](cpp-standard-library-reference.md)\
[C++ 標準ライブラリのスレッドセーフ](thread-safety-in-the-cpp-standard-library.md)
