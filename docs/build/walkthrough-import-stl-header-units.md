---
description: ヘッダー ユニットを使用して C++ 標準テンプレート ライブラリ (STL) のライブラリをインポートする方法について説明します。
title: 'チュートリアル: 標準テンプレート ライブラリ (STL) のライブラリをヘッダー ユニットとしてインポートする'
ms.date: 4/13/2021
ms.custom: conceptual
author: tylermsft
ms.author: twhitney
helpviewer_keywords:
- import
- header unit
- ifc
- stl
ms.openlocfilehash: 94c52d2f333c1b62bb06f2a653080906fe6877ef
ms.sourcegitcommit: bac5dde649d5b0447de1d26a73365e36d74595f3
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/13/2021
ms.locfileid: "107381428"
---
# <a name="walkthrough-import-stl-libraries-as-header-units"></a>チュートリアル: STL ライブラリをヘッダ ーユニットとしてインポートする

このチュートリアルでは、C++ 標準テンプレート ライブラリ (STL) のライブラリを Visual Studio にヘッダー ユニットとしてインポートする 2 つの方法について説明します。

[1 つ目の方法](#approach1)では、ユーザーがプロジェクトにインポートしている STL ヘッダーに基づいて、ビルド システムによってヘッダー ユニットが自動的にスキャンされてビルドされます。

[2 つ目の方法](#approach2)では、使用する STL ヘッダー用のヘッダー ユニットを含むスタティック ライブラリ プロジェクトをビルドした後、そのプロジェクトを参照してヘッダー ユニットをインポートする方法を示します。

STL ヘッダーをヘッダー ユニットとしてインポートすることは、[プリコンパイル済みヘッダー ファイル](creating-precompiled-header-files.md)に代わる、より簡単な方法です。 ヘッダー ユニットは、共有プリコンパイル済みヘッダー ファイル (PCH) より設定も使用も簡単でありながら、同程度のパフォーマンスを得られます。 PCH とは異なり、ヘッダー ユニットを変更したときにリビルドされるのは、それ自体とその依存関係だけです。

STL ヘッダーの場合は、インポートする前に、ヘッダー ユニットにコンパイルする必要があります。 ヘッダー ユニットは、ヘッダー ファイルのバイナリ表現であり、末尾の拡張子は *`.ifc`* です。

ヘッダー ユニットとヘッダー ファイルの重要な違いは、ヘッダー ユニットはマクロ定義の影響を受けないことです。 ヘッダー ファイルでは `#define` を使用してシンボルを定義し、インポート時の動作を変えることができますが、ヘッダー ユニットではそのようなことはできません。

類似点としては、ヘッダー ファイルから参照できるものはすべて、ヘッダー ユニットからも参照できます。

## <a name="prerequisites"></a>前提条件

ヘッダー ユニットをサポートするには、少なくとも Visual Studio 2019 16.10.0 Preview 2 が必要です。

## <a name="two-different-approaches"></a>2 つの異なるアプローチ

STL ヘッダーをインポートする前に、それをヘッダー ユニットにコンパイルする必要があります。 主な方法は、以下で示す 2 つです。

**モジュールの依存関係をスキャンする**

この方法の概要は、ソースで `import "header";` および `import <header>;` ステートメントをスキャンし、それらのヘッダー ファイルとその依存関係をヘッダー ユニットにコンパイルするというものです。 その後、プリプロセッサを使用してヘッダー ファイルを実行する代わりに、コンパイル済みのヘッダー ユニット ファイル ( *`.ifc`* ) をインポートします。

ヘッダー ユニットに組み込むヘッダーを見つけるためにファイル全体をスキャンする必要があるので、最適なビルド時間が保証されないため、大きいプロジェクトの場合は最適な方法ではありません。 これにより、同じヘッダー ファイルが繰り返し再処理され、ビルド時間が長くなる可能性があります。 また、すべてのヘッダー ファイルをヘッダー ユニットに自動的に変換できるわけではありません。 たとえば、`#define` シンボルを使用した条件付きコンパイルに依存するヘッダーは、ヘッダー ユニットとして機能しないことがあります。 ヘッダー ユニットにコンパイルできないヘッダー ファイルは、通常の `#include` ファイルとして扱われます。

この方法のチュートリアルについては、この記事の「[方法 1: インポートをスキャンする](#approach1)」を参照してください。

**スタティック ライブラリ プロジェクトを作成する**

特に大規模なプロジェクトの場合、または複数のプロジェクト間で共通のヘッダー ユニットのセットを共有する場合に推奨される方法は、共有するヘッダー ユニットが含まれるスタティック ライブラリ プロジェクトを作成することです。 その後、それらのヘッダー ユニットをインポートするプロジェクトで、このライブラリ プロジェクトを参照します。 これは、[共有プリコンパイル済みヘッダー](https://devblogs.microsoft.com/cppblog/shared-pch-usage-sample-in-visual-studio/)を使用するのと似ていますが、それより簡単です。

この方法のチュートリアルについては、この記事の「[方法 2: スタティック ライブラリ プロジェクトをビルドする](#approach2)」を参照してください。

## <a name="approach-1-scan-for-imports"></a><a name="approach1"></a>方法 1: インポートをスキャンする

最初に、ヘッダー ユニットとして STL ライブラリをインポートする最も簡単な方法について説明します。 この方法は、ソースで `import` ステートメントをスキャンするために最適なビルド時間が保証されないので、大規模なプロジェクトには適していない場合があります。

このオプションは、多くの異なるヘッダーが使用されていて、ビルドのスループットが重要ではないコードベースに便利です。 このオプションの場合、特定のヘッダーのヘッダー ユニットが 1 回だけビルドされることは保証されませんが、参照されているスタティック ライブラリ プロジェクトの一部であるヘッダー ユニットは再利用されます。

Visual C++ プロジェクトの **[モジュール依存関係のソースをスキャンする]** オプションを設定することにより、コードを変更することなく STL ライブラリをヘッダー ユニットとしてインポートできます。

これを設定すると、ビルド システムによって、ソース コードで `import` ディレクティブがスキャンされ、インポートされたヘッダー ファイルのヘッダー ユニットへのコンパイルが試みられます。 プロジェクト全体をスキャンする方法の他に、ヘッダー ファイルをヘッダー ユニットとして扱うように指定する方法もあります。 それについては、「[チュートリアル: Visual C++ プロジェクトでヘッダー ユニットをビルドしてインポートする](walkthrough-header-units.md)」を参照してください。

すべてのヘッダーをヘッダー ユニットに変換することはできません。 問題の 1 つは、`#define` シンボルに依存するヘッダー ファイルでは、ヘッダー ファイルのコンパイルが異なることです。 ヘッダー ファイルがこのメカニズムに依存している場合は、ヘッダー ユニットに変換されません。 代わりに、通常の `#include` として扱われます。

この方法を示すため、2 つの STL ライブラリをインポートするプロジェクトを作成した後、ライブラリをヘッダー ユニットとして扱うようにプロジェクトのプロパティを変更します。

### <a name="create-a-c-console-app-project"></a>C++ コンソール アプリ プロジェクトを作成する

このステップでは、2 つのライブラリ `<iostream>` と `<vector>` が含まれるプロジェクトを作成します。 その後、ヘッダー ユニットにコンパイルできる可能性のあるヘッダー ファイルがプロジェクトでスキャンされるように、プロジェクトの設定を変更します。

1. Visual Studio で新しい C++ コンソール アプリ プロジェクトを作成します。
1. ソース ファイルを次のように変更します。
    ```cpp
    import <iostream>;
    import <vector>;
    
    int main()
    {
        std::vector<int> numbers = {0, 1, 2};
        std::cout << numbers[1];
    }
    ```
    
### <a name="set-project-options-and-run-the-project"></a>プロジェクトのオプションを設定してプロジェクトを実行する

次の手順のようにして、ヘッダー ユニットにコンパイルできるインポート済みヘッダーがビルド システムによってスキャンされるようにするオプションを設定します。

1. メイン メニューから、 **[プロジェクト]**  >  **[プロパティ]** を選択します。 プロジェクトのプロパティ ウィンドウが表示されます。:::image type="content" source="media/vs2019-scan-module-dependencies.png" alt-text="プロジェクトのプロパティ ウィンドウでのモジュールの依存関係のスキャン プロパティの設定を示すスクリーンショット。":::
1. **[構成]** ドロップダウンを **[すべての構成]** に設定し、 **[プラットフォーム]** ドロップダウンを **[すべてのプラットフォーム]** に設定することもできます。 このようにすると、デバッグまたはリリース用のビルドかどうかにかかわらず、変更した設定が適用されます。
1. プロジェクトのプロパティ ページの左側のペインで、 **[C/C++]**  >  **[全般]** を選択します。
1. **[モジュール依存関係のソースをスキャンする]** を **[はい]** に設定します。 プロジェクトのプロパティを設定しているため、このプロジェクトのすべてのソースがスキャンされます。

コンパイラの C++ 言語標準を変更します。 ヘッダー ユニットを使用するには、[`/std:c++latest`](./reference/std-specify-language-standard-version.md) スイッチが必要です。

1. プロジェクトのプロパティ ページの左側のペインで、 **[構成プロパティ]**  >  **[全般]** を選択します。
1. **[C++ 言語標準]** ドロップダウンを **[プレビュー - 最新の C++ Working Draft からの機能 (/std:c++latest)]** に変更します。
:::image type="content" source="media/set-cpp-language-latest.png" alt-text="言語標準の設定場所を示すスクリーンショット。":::
1. **[OK]** をクリックしてプロジェクトのプロパティ ページを閉じ、メイン メニューから **[ビルド]**  >  **[ソリューションのビルド]** を選択してソリューションをビルドします。

ソリューションを実行して、予想される出力 `1` が生成されることを確認できます。

この方法の主な考慮事項は、便利さと、ヘッダー ユニットとしてビルドするヘッダーファイルを決定するためにすべてのファイルをスキャンするビルド コストの間のバランスを取ることです。

インポートの依存関係をスキャンせず、代わりにヘッダー ユニットとしてビルドする必要のあるファイルを明示的にマークすることで、このバランスを微調整できます。 この方法については、「[チュートリアル: Visual C++ プロジェクトでヘッダー ユニットをビルドしてインポートする](walkthrough-header-units.md)」を参照してください

## <a name="approach-2-build-a-static-library-project"></a><a name="approach2"></a>方法 2: スタティック ライブラリ プロジェクトをビルドする

STL ヘッダーを使用するさらに柔軟な方法は、再利用する STL ヘッダーからヘッダー ユニットをビルドする 1 つ以上のスタティック ライブラリ プロジェクトを作成することです。 その後、それらの STL ヘッダーを必要とするプロジェクトから、そのライブラリ プロジェクト (1 つまたは複数) を参照します。 スタティック ライブラリ プロジェクトでビルドされたモジュールとヘッダー ユニットは、参照しているプロジェクトで自動的に使用できます。 プロジェクト システムにより、適切な [/headerUnit](./reference/headerunit.md) スイッチがコマンド ラインに自動的に追加され、参照しているプロジェクトでヘッダー ユニットをインポートできるようになります。

このオプションを使用すると、特定のヘッダーのヘッダー ユニットが 1 回だけビルドされるようになります。 これは、共有プリコンパイル済みヘッダー ファイルを使用するのと似ていますが、はるかに簡単です。

この例では、`<iostream>` と `<vector>` をインポートするプロジェクトを作成します。 ビルドが完了したら、この共有ヘッダー ユニット プロジェクトを別の C++ プロジェクトから参照します。 その後、参照しているプロジェクト内の `import <iostream>;` または `import <vector>;` が使用されているすべての場所で、プリプロセッサによってライブラリ ヘッダーの内容が実行されるのではなく、そのライブラリのビルド済みヘッダー ユニットがインポートされます。 同じライブラリ ヘッダーが複数のファイルに含まれるプロジェクトの場合、ヘッダーが含まれるファイルでヘッダーを繰り返し処理する必要がないため、PCH ファイルの場合と同様に、ビルドのパフォーマンスが向上します。 代わりに、既に処理されているコンパイル済みヘッダー ユニットがインポートされます。

### <a name="create-the-shared-header-unit-project"></a>共有ヘッダー ユニット プロジェクトを作成する

最初に、次のようにして、共有ヘッダー ユニット用のプロジェクトを作成します。

1. 空の C++ プロジェクトを作成します。 それを呼び出します (この例では **SharedPrj**)。\
 **[新しいプロジェクトの作成]** ウィンドウで、使用可能なプロジェクトの種類から **空の C++ プロジェクト** を選択します。:::image type="content" source="media/empty-project-option.png" alt-text="新しい空の C++ プロジェクトの作成を示すスクリーンショット。":::
1. 新しい (空の) C++ ファイルをプロジェクトに追加します。 ファイルの内容を次のように変更します。

    ```cpp
    import <iostream>;
    import <vector>;
    ```

### <a name="set-project-properties"></a>プロジェクト プロパティを設定する

このプロジェクトからヘッダー ユニットを共有するように、プロジェクトのプロパティを設定します。

1. Visual Studio のメイン メニューから、 **[プロジェクト]**  >  **[プロパティ]** を選択します。 プロジェクトのプロパティ ウィンドウが表示されます。:::image type="content" source="media/set-header-unit-library-settings.png" alt-text="構成の種類と C++ 言語標準の設定を示すスクリーンショット。":::
1. **[構成]** ドロップダウンを **[すべての構成]** に設定し、 **[プラットフォーム]** ドロップダウンを **[すべてのプラットフォーム]** に設定することもできます。 このようにすると、デバッグまたはリテール用のビルドかどうかにかかわらず、変更した設定が適用されます。
1. プロジェクトのプロパティ ページの左側のペインで、 **[全般]** を選択します
1. **[構成の種類]** オプションを **[スタティック ライブラリ (.lib)]** に変更します
1. **[C++ 言語標準]** を **[プレビュー - 最新の C++ Working Draft からの機能 (/std:c++latest)]** に変更します
1. プロジェクトのプロパティ ページの左側のペインで、 **[C/C++]**  >  **[全般]** を選択します 
:::image type="content" source="media/vs2019-scan-module-dependencies.png" alt-text="モジュール依存関係のスキャン プロパティの設定を示すスクリーンショット。":::
1. **[モジュール依存関係のソースをスキャンする]** ドロップダウンを **[はい]** に設定します。
1. **[OK]** をクリックしてプロジェクトのプロパティ ページを閉じ、メイン メニューから **[ビルド]**  >  **[ソリューションのビルド]** を選択してソリューションをビルドします。

## <a name="reference-the-shared-header-unit-project"></a>共有ヘッダー ユニット プロジェクトを参照する

次に、ビルドされた共有ヘッダー プロジェクト `<vector>` と `<iostream>` を使用するプロジェクトを作成します。

1. 現在のソリューションを開いたまま、Visual Studio のメニューから **[ファイル]**  >  **[追加]**   >  **[新しいプロジェクト]** を選択します。
1. C++ コンソール アプリ プロジェクトを追加します。 この例では、それを **Walkthrough** という名前にします。
1. そのソース ファイルの内容を次のように変更します。

    ```cpp
    import <iostream>;
    import <vector>;
    
    int main()
    {
        std::vector<int> numbers = {0, 1, 2};
        std::cout << numbers[1];
    }
    ```

コンパイラの **[C++ 言語標準]** を変更します。 ヘッダー ユニットを使用するには、[`/std:c++latest`](./reference/std-specify-language-standard-version.md) スイッチが必要です。
1. **ソリューション エクスプローラー** で **Walkthrough** プロジェクトを右クリックして、 **[プロパティ]** を選択します。 プロジェクトのプロパティ ウィンドウが表示されます。
:::image type="content" source="media/set-cpp-language-latest.png" alt-text="言語標準をプレビュー バージョンに設定するスクリーンショット":::
1. **Walkthrough** プロジェクトのプロパティ ページの左側のペインで、 **[構成プロパティ]**  >  **[全般]** を選択します
1. **[C++ 言語標準]** を **[プレビュー - 最新の C++ Working Draft からの機能 (/std:c++latest)]** に変更します
1. **[OK]** をクリックしてプロジェクトのプロパティ ページを閉じます

**Walkthrough** プロジェクトから **SharedPrj** プロジェクトへの参照を追加します。

1. **Walkthrough** プロジェクトで **[参照設定]** ノードをクリックし、 **[参照の追加]** を選択します。 プロジェクトの一覧から **SharedPrj** を選択します。 
:::image type="content" source="./media/add-reference-to-walkthrough.png" alt-text="[参照の追加] ダイアログを示すスクリーンショット。Walkthrough プロジェクトへの参照を追加するために使用されます。":::
この参照により、**Walkthrough** プロジェクト内の `import` が **SharedPrj** 内のいずれかのビルド済みヘッダー ユニットと一致するたびに、**SharedPrj** によってビルドされたヘッダー ユニットがビルド システムで使用されます
1. **[OK]** をクリックして、 **[参照の追加]** ダイアログを閉じます
1. **Walkthrough** プロジェクトを右クリックし、 **[スタートアップ プロジェクトに設定]** を選択します

次に、ソリューションをビルドして (メイン メニューから **[ビルド]**  >  **[ソリューションのビルド]** )、実行して、予想される出力 `1` が生成されることを確認します。

この方法の利点は、任意のプロジェクトからスタティック ライブラリ プロジェクトを参照して、ヘッダー ユニットを再利用できることです。 この例では、それは `<vector>` と `<iostream>` です。  

さまざまなプロジェクトからインポートする一般的に使用されるすべての STL ヘッダーを含むモノリシックなスタティック ライブラリ プロジェクトを作成できます。 または、ヘッダー ユニットとしてインポートする STL ライブラリのさまざまなグループ用に、より小さな共有ライブラリ プロジェクトを作成することもできます。 その後、必要に応じて、それらの共有ヘッダー ユニット プロジェクトを参照します。

結果として、ヘッダー ユニットをインポートすると、コンパイラで行う必要のある作業が大幅に減るため、ビルドのスループットが向上します。

独自のプロジェクトでこれを行う場合は、スタティック ライブラリ プロジェクトをビルドするときに、それを参照するプロジェクトと互換性のあるコンパイラ スイッチを使用することが重要です。 たとえば、STL プロジェクトは例外処理を有効にするために `/EHsc` コンパイラ スイッチを使用してビルドする必要があるため、スタティック ライブラリ プロジェクトを参照するプロジェクトでもそれが必要になります。

## `/translateInclude`

[`/translateInclude`](./reference/translateinclude.md) コンパイラ スイッチを使用すると、参照されている共有ヘッダー ユニット プロジェクトをプロジェクトから簡単に使用できるようになります。

これは、参照される共有ヘッダー ユニット プロジェクトからビルド済みヘッダー ユニットのインポートを利用するために、プロジェクト内の `#include` ディレクティブを変更する必要がないため便利です。

たとえば、プロジェクトに `#include <vector>` があり、`<vector>` 用のヘッダー ユニットが含まれる共有ヘッダー ユニット プロジェクトを参照する場合、手動でソース コードの `#include <vector>` を `import <vector>;` に変更する必要はありません。 `/translateInclude` を指定した場合 (プロジェクトのプロパティ ダイアログの **[C/C++]**  >  **[全般]**  >  **[Translate Includes to Imports]\(インクルードをインポートに変換する\)** にあります)、コンパイラによって自動的に `#include <vector>` は `import <vector>;` として処理されます。これは、共有ヘッダー ユニット プロジェクト内のビルド済みヘッダー ユニットを参照するすべての `#include` ステートメントに適用されます。 それ以外の場合は、通常の `#include` として扱われます。

## <a name="reuse-header-units-between-projects"></a>プロジェクト間でヘッダー ユニットを再利用する

スタティック ライブラリ プロジェクトによってビルドされたヘッダー ユニットは、直接的または間接的に参照しているすべてのプロジェクトで自動的に使用できるようになります。 参照しているすべてのプロジェクトで自動的に使用できるようにする必要があるヘッダー ユニットを選択できプロジェクト設定があります。 この設定は、プロジェクトの設定の **[VC++ ディレクトリ]** にあります。
1. **ソリューション エクスプローラー** でプロジェクトを選択し、プロジェクトを右クリックして、 **[プロパティ]** を選択します。
1. プロジェクトのプロパティ ウィンドウの左側のペインで、 **[VC++ ディレクトリ]** を選択します。
:::image type="content" source="media/public-include-module-directories-setting.png" alt-text="パブリックなインクルード ディレクトリ、すべてのヘッダー ファイルがパブリックなど、パブリック プロジェクトの内容のプロパティを示すスクリーンショット。":::

次の設定により、ビルド システムに対するヘッダー ユニットの可視性が制御されます。

- **[パブリック インクルード ディレクトリ]** : 参照しているプロジェクトのインクルード パスに自動的に追加する必要があるヘッダー ユニット用プロジェクト ディレクトリを指定します。
- **[パブリック C++ モジュール ディレクトリ]** : 参照しているプロジェクトで使用できるようにする必要があるヘッダー ユニットが含まれるプロジェクト ディレクトリを指定します。 この方法により、他のプロジェクトから参照できる場所で共有できるヘッダー ユニットを配置できる場所を提供することで、ヘッダー ユニットを公開します。 これを設定した場合は、 **[パブリック インクルード ディレクトリ]** も指定して、参照しているプロジェクトのインクルード パスにパブリック ヘッダーを自動的に追加できます。
- **[すべてのモジュールがパブリックである]** : DLL プロジェクトの一部としてビルドされたヘッダー ユニットを使用するには、シンボルを DLL からエクスポートする必要があります。 そのためには、このプロパティを **[はい]** に設定します。

## <a name="use-a-prebuilt-module-file"></a>ビルド済みのモジュール ファイルを使用する

通常、ソリューション間でヘッダー ユニットを再利用する最も簡単な方法は、各ソリューションから同じ共有ヘッダー ユニット プロジェクトを参照することです。

ただし、プロジェクトがないビルド済みヘッダー ユニットを使用する必要がある場合は、ソリューションにインポートできるように、ビルド済みの *`.ifc`* ファイルの場所を指定できます。

この設定にアクセスするには:
1. メイン メニューから、 **[プロジェクト]**  >  **[プロパティ]** を選択します。 プロジェクトのプロパティ ウィンドウが表示されます。
1. プロジェクトのプロパティ ウィンドウの左側のペインで、 **[C/C++]**  >  **[全般]** を選択します。
1. **[追加のモジュールの依存関係]** ドロップダウンで、参照するモジュールを追加します。 **[追加のモジュールの依存関係]** に使用する形式の例を次に示します。`ModuleName1=Path\To\ModuleName1.ifc; ModuleName2=Path\To\ModuleName2.ifc`
:::image type="content" source="media/vs2019-additional-module-dependencies.png" alt-text="[C/C++] の [全般] の下で [追加のモジュールの依存関係] が選択されているプロジェクトのプロパティを示すスクリーンショット。":::

## <a name="select-among-multiple-copies-of-a-header-unit"></a>ヘッダー ユニットの複数のコピーから選択する
 
参照する複数のプロジェクトで、同じ名前の複数のヘッダー ユニットがビルドされている場合、または同じヘッダー ファイルに対して複数のヘッダー ユニットがビルドされている場合は、同じインポートに対して選択する複数のヘッダー ユニットがあります。 たとえば、異なるコンパイラ設定を使用してビルドされた異なるバージョンのヘッダー ユニットがあり、使用するものをコンパイラに通知することが必要な場合があります。

使用する必要があるヘッダー ユニットを指定することによって競合を解決するには、プロジェクトのプロパティの **[C/C++]**  >   **[追加のヘッダー ユニットの依存関係]** を使用します。 そうしないと、どれが選択されるかを予測することはできません。

この設定にアクセスするには:
1. メイン メニューから、 **[プロジェクト]**  >  **[プロパティ]** を選択します。 プロジェクトのプロパティ ウィンドウが表示されます。
1. プロジェクトのプロパティ ウィンドウの左側のペインで、 **[C/C++]**  >  **[全般]** を選択します。
1. このプロジェクトで使用する必要があるモジュールまたはヘッダー ユニットを指定することによって競合を解決するには、 **[追加のヘッダー ユニットの依存関係]** を使用します。 **[追加のヘッダー ユニットの依存関係]** では、`Path\To\Header1.h= Path\To\HeaderUnit1.ifc;Path\To\Header2.h= Path\To\ HeaderUnit2.ifc` という形式を使用します。
:::image type="content" source="media/additional-header-unit-dependencies-setting.png" alt-text="プロジェクトのプロパティ ダイアログでの [追加のヘッダー ユニットの依存関係] の設定を示すスクリーンショット。":::

> [!IMPORTANT]
> ヘッダー ユニットを共有するプロジェクトが、互換性のあるコンパイル オプションを使用してビルドされていることを確認します。 ヘッダー ユニットの生成と使用で異なるコンパイル オプションが使用されていることが検出されると、コンパイラで警告が発生します。

> [!NOTE]
> **DLL** プロジェクトの一部としてビルドされたヘッダー ユニットを使用するには、プロジェクトのプロパティの設定 **[すべてのモジュールがパブリックである]** を **[はい]** に設定する必要があります。

## <a name="see-also"></a>関連項目

[チュートリアル: Visual C++ プロジェクトでヘッダー ユニットをビルドしてインポートする](walkthrough-header-units.md) \
[`/translateInclude`](./reference/translateinclude.md)
