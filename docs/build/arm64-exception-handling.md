---
title: ARM64 例外処理
description: ARM64 版 Windows によって使用される例外処理の規則およびデータについて説明します。
ms.date: 11/19/2018
ms.openlocfilehash: b1137e4e46e1127ea5452e93e1d8d9452ba0ea4d
ms.sourcegitcommit: dc77cf3b5b644d8e2adf595540b98194ab95c6e1
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/05/2021
ms.locfileid: "106377269"
---
# <a name="arm64-exception-handling"></a>ARM64 例外処理

ARM64 版 Windows は、ハードウェアで生成される非同期例外とソフトウェアで生成される同期例外に対して、同じ構造化例外処理メカニズムを使用します。 言語固有の例外ハンドラーは、言語ヘルパー関数を使用することで、Windows 構造化例外処理に付加して構築します。 このドキュメントでは、ARM64 版 Windows における例外処理と、Microsoft ARM アセンブラーおよび MSVC コンパイラによって生成されるコードによって使用される言語ヘルパーについて説明します。

## <a name="goals-and-motivation"></a>目的と動機

例外アンワインド データ規則およびこの記述は、次のことを目的としています。

1. どのような場合でも、コード プローブを使用しないアンワインドができるように十分な記述を提供します。

   - コードを分析するには、コードをページインする必要があります。 これにより、アンワインドが、それが有用な状況 (トレース、サンプリング、デバッグ) において使用できなくなります。

   - コードの分析は複雑です。コンパイラは、アンワインダーがデコードできる命令だけを生成するように注意する必要があります。

   - アンワインド コードを使用してアンワインドを完全に記述できない場合、場合によっては命令デコードにフォールバックする必要があります。 これにより全体の複雑さが増すため、これは避けることをお勧めします。

1. プロローグ中およびエピローグ中のアンワインドをサポートします。

   - アンワインドは Windows で例外処理以外の目的でも使用されます。 プロローグまたはエピローグのコード シーケンスの途中であっても、コードを正確にアンワインドできることが重要です。

1. 使用する容量を最小限にします。

   - バイナリ サイズが大幅に増加するようなアンワインド コードの集約はしないでください。

   - アンワインド コードはメモリ内でロックされる可能性が高いため、フットプリントを小さくすると、読み込まれる各バイナリのオーバーヘッドが最小限に抑えられます。

## <a name="assumptions"></a>外部からの影響

例外処理の記述では、次のことが前提となっています。

1. 通常、プロローグとエピローグは、相互にミラー化されます。 この共通の特徴を利用することで、アンワインドを記述するために必要なメタデータのサイズを大幅に削減できます。 関数本体内で、プロローグの演算が元に戻されるか、先に進んでエピローグの演算が実行されるかは関係ありません。 両方の場合で同じ結果となります。

1. 関数は全体として比較的小さい傾向があります。 領域の最適化のいくつかは、データの最も効率的なパッキングを実現するために、この事実に依存しています。

1. エピローグに条件付きコードはありません。

1. 専用フレーム ポインター レジスタ:sp がプロローグ内の別のレジスタ (x29) に保存されている場合、そのレジスタは関数全体で変更されずに保持されます。 これは、元の sp がいつでも復旧できることを意味します。

1. sp が別のレジスタに保存されていない限り、スタック ポインターのすべての操作は、厳密にプロローグおよびエピローグ内で発生します。

1. スタック フレームのレイアウトは、次のセクションで説明するように構成されています。

## <a name="arm64-stack-frame-layout"></a>ARM64 のスタック フレームのレイアウト

![スタック フレームのレイアウト](media/arm64-exception-handling-stack-frame.png "スタック フレームのレイアウト")

フレーム チェーン関数の場合、fp と lr のペアは、最適化の考慮事項に応じてローカル変数領域内の任意の位置に保存できます。 目的は、フレーム ポインター (x29) またはスタック ポインター (sp) に基づいて 1 つの命令によって到達できるローカルの数を最大化することです。 ただし `alloca` 関数の場合は、これをチェーンする必要があり、x29 はスタックの一番下を指している必要があります。 レジスタ ペア アドレス指定モードのカバレッジを向上させるために、不揮発性レジスタの保存領域がローカル領域スタックの最上位に配置されます。 ここでは、最も効率的なプロローグ シーケンスの例をいくつか紹介します。 わかりやすくするため、およびキャッシュの局所性を向上させるために、すべての標準プロローグでの、呼び出し先保存レジスタを格納する順序は "拡大" 順です。 次に示す `#framesz` は、スタック全体のサイズ (alloca 領域を除く) です。 `#localsz` と `#outsz` は、それぞれローカル領域のサイズ (\<x29, lr> ペアの保存領域を含む)、および出力パラメーターのサイズを表します。

1. チェーン、#localsz \<= 512

    ```asm
        stp    x19,x20,[sp,#-96]!        // pre-indexed, save in 1st FP/INT pair
        stp    d8,d9,[sp,#16]            // save in FP regs (optional)
        stp    x0,x1,[sp,#32]            // home params (optional)
        stp    x2,x3,[sp,#48]
        stp    x4,x5,[sp,#64]
        stp    x6,x7,[sp,#72]
        stp    x29,lr,[sp,#-localsz]!   // save <x29,lr> at bottom of local area
        mov    x29,sp                   // x29 points to bottom of local
        sub    sp,sp,#outsz             // (optional for #outsz != 0)
    ```

1. チェーン、#localsz > 512

    ```asm
        stp    x19,x20,[sp,#-96]!        // pre-indexed, save in 1st FP/INT pair
        stp    d8,d9,[sp,#16]            // save in FP regs (optional)
        stp    x0,x1,[sp,#32]            // home params (optional)
        stp    x2,x3,[sp,#48]
        stp    x4,x5,[sp,#64]
        stp    x6,x7,[sp,#72]
        sub    sp,sp,#(localsz+outsz)   // allocate remaining frame
        stp    x29,lr,[sp,#outsz]       // save <x29,lr> at bottom of local area
        add    x29,sp,#outsz            // setup x29 points to bottom of local area
    ```

1. 非チェーン、リーフ関数 (lr 未保存)

    ```asm
        stp    x19,x20,[sp,#-80]!       // pre-indexed, save in 1st FP/INT reg-pair
        stp    x21,x22,[sp,#16]
        str    x23,[sp,#32]
        stp    d8,d9,[sp,#40]           // save FP regs (optional)
        stp    d10,d11,[sp,#56]
        sub    sp,sp,#(framesz-80)      // allocate the remaining local area
    ```

   すべてのローカルは、SP に基づいてアクセスされます。 \<x29,lr> は前のフレームを指します。 フレームサイズ \<= 512 の場合、regs 保存領域をスタックの一番下に移動すると、"sub sp, ..." を最適化できます。 欠点は、上の他のレイアウトと一貫性がないことと、保存されている regs が、ペア regs と、事前および事後インデックスされたオフセット アドレス指定モードの範囲の一部となることです。

1. 非チェーン、非リーフ関数 (lr は Int 保存領域に保存されます)

    ```asm
        stp    x19,x20,[sp,#-80]!       // pre-indexed, save in 1st FP/INT reg-pair
        stp    x21,x22,[sp,#16]         // ...
        stp    x23,lr,[sp,#32]          // save last Int reg and lr
        stp    d8,d9,[sp,#48]           // save FP reg-pair (optional)
        stp    d10,d11,[sp,#64]         // ...
        sub    sp,sp,#(framesz-80)      // allocate the remaining local area
    ```

   または、偶数値の保存 Int レジスタの場合、

    ```asm
        stp    x19,x20,[sp,#-80]!       // pre-indexed, save in 1st FP/INT reg-pair
        stp    x21,x22,[sp,#16]         // ...
        str    lr,[sp,#32]              // save lr
        stp    d8,d9,[sp,#40]           // save FP reg-pair (optional)
        stp    d10,d11,[sp,#56]         // ...
        sub    sp,sp,#(framesz-80)      // allocate the remaining local area
    ```

   x19 のみが保存されます:

    ```asm
        sub    sp,sp,#16                // reg save area allocation*
        stp    x19,lr,[sp]              // save x19, lr
        sub    sp,sp,#(framesz-16)      // allocate the remaining local area
    ```

   \* 事前インデックスされた reg-lr stp はアンワインド コードで表すことができないため、reg save area allocation (reg 保存領域割り当て) は、stp に折り込まれません。

   すべてのローカルは、SP に基づいてアクセスされます。 \<x29> は前のフレームを指します。

1. チェーン、#framesz \<= 512、#outsz = 0

    ```asm
        stp    x29,lr,[sp,#-framesz]!       // pre-indexed, save <x29,lr>
        mov    x29,sp                       // x29 points to bottom of stack
        stp    x19,x20,[sp,#(framesz-32)]   // save INT pair
        stp    d8,d9,[sp,#(framesz-16)]     // save FP pair
    ```

   上記の最初のプロローグの例と比較して、ここでの利点は、すべてのレジスタ保存命令が、わずか 1 つのスタック割り当て命令の後に実行できるようになることです。 つまり、命令レベルの並列化を妨げる sp への反依存性はありません。

1. チェーン、フレーム サイズ > 512 (alloca のない関数の場合は省略可能)

    ```asm
        stp    x29,lr,[sp,#-80]!            // pre-indexed, save <x29,lr>
        stp    x19,x20,[sp,#16]             // save in INT regs
        stp    x21,x22,[sp,#32]             // ...
        stp    d8,d9,[sp,#48]               // save in FP regs
        stp    d10,d11,[sp,#64]
        mov    x29,sp                       // x29 points to top of local area
        sub    sp,sp,#(framesz-80)          // allocate the remaining local area
    ```

   最適化のために、x29 をローカル領域内の任意の位置に配置して、"reg ペア" と事前および事後インデックスされたオフセット アドレス指定モードのカバレッジを向上させることができます。 フレーム ポインターの下にあるローカルは、SP に基づいてアクセスできます。

1. チェーン、フレーム サイズ > 4K、alloca() 有りまたは無し

    ```asm
        stp    x29,lr,[sp,#-80]!            // pre-indexed, save <x29,lr>
        stp    x19,x20,[sp,#16]             // save in INT regs
        stp    x21,x22,[sp,#32]             // ...
        stp    d8,d9,[sp,#48]               // save in FP regs
        stp    d10,d11,[sp,#64]
        mov    x29,sp                       // x29 points to top of local area
        mov    x15,#(framesz/16)
        bl     __chkstk
        sub    sp,sp,x15,lsl#4              // allocate remaining frame
                                            // end of prolog
        ...
        sub    sp,sp,#alloca                // more alloca() in body
        ...
                                            // beginning of epilog
        mov    sp,x29                       // sp points to top of local area
        ldp    d10,d11,[sp,#64]
        ...
        ldp    x29,lr,[sp],#80              // post-indexed, reload <x29,lr>
    ```

## <a name="arm64-exception-handling-information"></a>ARM64 例外処理情報

### <a name="pdata-records"></a>.pdata レコード

.pdata レコードは、PE バイナリ内の各スタック操作関数を記述する、固定長項目の順序付けされた配列です。 "スタック操作" という語句は重要であり、ローカル ストレージを必要とせず、非揮発性レジスタを保存/復元する必要がないリーフ関数は、.pdata レコードを必要としません。 領域を節約するために、これらのレコードを明示的に省略する必要があります。 これらのいずれかの関数からアンワインドすると、呼び出し元に移動するための戻り先アドレスを LR から直接取得できます。

ARM64 の各 .pdata レコードの長さは 8 バイトです。 各レコードの一般的な形式では、最初のワードに関数の開始の 32 ビット RVA が配置され、その後の 2 番目のワードには可変長 .xdata ブロックへのポインター、または標準関数アンワインド シーケンスを記述するパックされたワードが含まれます。

![.pdata レコードのレイアウト](media/arm64-exception-handling-pdata-record.png ".pdata レコードのレイアウト")

フィールドは次のとおりです。

- **関数開始 RVA** は、関数の開始の 32 ビット の RVA です。

- **フラグ** は、2 番目の .pdata ワードである残りの 30 ビットを解釈する方法を示す 2 ビット フィールドです。 **フラグ** が 0 の場合、残りのビットは **例外情報 RVA** (2 つの最下位ビットが暗黙的に 0) を形成します。 **フラグ** が 0 以外の場合、残りのビットは **パックされたアンワインド データ** 構造体を形成します。

- **例外情報 RVA** は、.xdata セクションに格納されている可変長例外情報構造体のアドレスです。 このデータは、4 バイトでアラインされている必要があります。

- **パックされたアンワインド データ** は、関数からのアンワインドに必要な演算の圧縮記述です (標準の形式を想定)。 この場合、.xdata レコードは必要ありません。

### <a name="xdata-records"></a>.xdata レコード

パックされたアンワインド形式では関数のアンワインドの記述に十分でない場合、可変長の .xdata レコードを作成する必要があります。 このレコードのアドレスは、.pdata レコードの第 2 ワードに格納されています。 .xdata の形式は、パックされた可変長ワード セットです。

![.xdata レコードのレイアウト](media/arm64-exception-handling-xdata-record.png ".xdata レコードのレイアウト")

このデータは、次の 4 つのセクションに分かれています。

1. 構造体全体のサイズを記述し、主な関数データを提供する 1 ～ 2 ワードのヘッダー。 2 番目のワードは、**エピローグ カウント** と **コード ワード** フィールドの両方が 0 に設定されている場合にのみ存在します。 ヘッダーには、次のビット フィールドがあります。

   a. **Function Length** は 18 ビット フィールドです。 これは関数全体の長さを 4 で除算してバイト単位で示します。 関数が 1M より大きい場合、複数の .pdata および .xdata レコードを使用して関数を記述する必要があります。 詳細については、「[大きな関数](#large-functions)」セクションを参照してください。

   b. **Vers** は 2 ビットフィールドです。 これは残りの .xdata のバージョンを記述します。 現時点では、バージョン 0 のみが定義されているため、1 ～ 3 の値は使用できません。

   c. **X** は 1 ビット フィールドです。 これは、例外データが存在する (1) か存在しない (0) かを示します。

   d. **E** は 1 ビット フィールドです。 これは、追加のスコープ ワードを後で必要とする (0) のではなく単一のエピローグを記述した情報がヘッダーにパックされている (1) ことを示します。

   e. **Epilog Count** は、**E** ビットの状態に応じて 2 つの意味を持つ 5 ビット フィールドです。

      1. **E** が 0 の場合は、セクション 2 で説明されているエピローグ スコープの合計数を指定します。 32 個以上のスコープが関数に存在する場合、**Code Words** フィールドが 0 に設定され、拡張ワードが必要であることを示す必要があります。

      2. **E** が 1 の場合、このフィールドは、エピローグのみを記述する最初のアンワインド コードのインデックスを指定します。

   f. **Code Words** は、すべてのアンワインド コードをセクション 3 に含めるために必要な 32 ビット ワードの数を指定する 5 ビット フィールドです。 32 ワード以上必要な場合 (つまり、125 個以上のアンワインド コード バイトがある場合)、このフィールドは、拡張ワードが必要であることを示すために 0 でなければなりません。

   g. **Extended Epilog Count** および **Extended Code Words** は、それぞれ 16 ビットおよび 8 ビットのフィールドです。 これらは、エピローグの数が通常よりも多い場合や、アンワインド コード ワードの数が通常よりも多い場合に、エンコーディング用の追加の領域を提供します。 これらのフィールドを含む拡張ワードは、1 番目のヘッダー ワードの **Epilog Count** と **Code Words** フィールドの両方が 0 の場合にのみ存在します。

1. **Epilog Count** が 0 でない場合は、エピローグ スコープについての情報の一覧が 1 つのワードにまとめられて、ヘッダーと省略可能な拡張ヘッダーの後に続きます。 これらは、開始オフセットが増加する順に格納されます。 各スコープには、以下のビットが含まれています。

   a. **Epilog Start Offset** は、関数の開始を基準にしたエピローグの (バイト単位の) オフセットを 4 で除算した値を示す 18 ビット フィールドです。

   b. **Res** は、将来の拡張用に予約された 4 ビット フィールドです。 この値は 0 である必要があります。

   c. **Epilog Start Index** は 10 ビット フィールドです (**Extended Code Words** よりも 2 ビット多い)。 これは、このエピローグを記述する最初のアンワインド コードのバイト インデックスを示します。

1. エピローグ スコープのリストの後には、アンワインド コードを含むバイトの配列が続きます (詳細については後のセクションで説明します)。 この配列は、最も近いフルワード境界の末尾に埋め込まれます。 アンワインド コードは、この配列に書き込まれます。 これらは関数の本体に最も近いものから開始し、関数の端に向かって移動します。 各アンワインド コードのバイトは、最上位バイトから順にフェッチできるようにビッグエンディアン順に格納されます。これにより、演算と残りのコードの長さが識別されます。

1. 最後に、ヘッダーの **X** ビットが 1 に設定されている場合、アンワインド コード バイトの後に例外ハンドラー情報が続きます。 これは、例外ハンドラー自体のアドレスを提供する単一の **例外ハンドラー RVA** で構成されます。 その直後に、例外ハンドラーに必要な可変長のデータが続きます。

.xdata レコードは、最初の 8 バイトをフェッチし、これらを使用してフル サイズのレコード (後続の可変サイズの例外データの長さを引く) を計算できるように設計されています。 次のコード スニペットはレコードのサイズを計算します。

```cpp
ULONG ComputeXdataSize(PULONG Xdata)
{
    ULONG Size;
    ULONG EpilogScopes;
    ULONG UnwindWords;

    if ((Xdata[0] >> 22) != 0) {
        Size = 4;
        EpilogScopes = (Xdata[0] >> 22) & 0x1f;
        UnwindWords = (Xdata[0] >> 27) & 0x1f;
    } else {
        Size = 8;
        EpilogScopes = Xdata[1] & 0xffff;
        UnwindWords = (Xdata[1] >> 16) & 0xff;
    }

    if (!(Xdata[0] & (1 << 21))) {
        Size += 4 * EpilogScopes;
    }

    Size += 4 * UnwindWords;

    if (Xdata[0] & (1 << 20)) {
        Size += 4;  // Exception handler RVA
    }

    return Size;
}
```

プロローグおよび各エピローグにはアンワインド コードの独自のインデックスがありますが、表はこれらの間で共有されます。 これらすべてが同じコードを共有することは可能です (全く珍しいことではありません)。 (例については、「[例](#examples)」のセクションの例 2 を参照してください。)コンパイラの作成者は特にこの状況に合わせて最適化する必要があります。これは、指定可能な最も大きいインデックスは 255 であり、このことによって、特定の関数のアンワインド コードの合計数が制限されるためです。

### <a name="unwind-codes"></a>アンワインド コード

アンワインド コードの配列は、プロローグの効果を元に戻す方法を正確に記述したシーケンスのプールで、操作を元に戻すのと同じ順序で格納されています。 アンワインド コードは、バイト列としてエンコードされた小さな命令セットと見なすことができます。 実行が完了すると、呼び出し元の関数の戻り先アドレスは lr レジスタに入ります。 また、すべての非揮発性レジスタは、関数が呼び出された時点の値が復元されます。

例外が関数本体のみで発生し、プロローグまたはエピローグでは絶対に発生しないことが保証されている場合、必要なシーケンスは 1 つのみです。 ただし、Windows アンワインド モデルでは、部分的に実行されたプロローグまたはエピローグからコードをアンワインドできる必要があります。 この要件を満たすため、アンワインド コードはプロローグおよびエピローグ内の各関連オペコードに 1:1 で明確にマッピングするように慎重に設計されています。 この設計は、次のような結果をもたらします。

1. アンワインド コードの数のカウントにより、プロローグおよびエピローグの長さの計算が可能です。

1. エピローグ スコープの開始後の命令の数をカウントすることにより、同じ数のアンワインド コードをスキップできます。 その後、シーケンスの残りの部分を実行して、エピローグによって実行される、部分的に実行されたアンワインドを完了できます。

1. プロローグの終了前の命令の数をカウントすることにより、同じ数のアンワインド コードをスキップできます。 その後、シーケンスの残りの部分を実行して、実行を完了したプロローグの部分のみを元に戻すことができます。

アンワインド コードは、次の表に従ってエンコードされます。 すべてのアンワインド コードは、大きなスタックを割り当てるものを除いて 1 バイトまたは 2 バイトです。 アンワインド コードは全部で 21 個あります。 各アンワインド コードは、部分的に実行されたプロローグとエピローグのアンワインドを可能にするために、プロローグ/エピローグ内の 1 つの命令に厳密にマップされます。

|アンワインド コード|ビットと解釈|
|-|-|
|`alloc_s`|000xxxxx: サイズ \< 512 (2^5 * 16) の小さいスタックを割り当てます。|
|`save_r19r20_x`|    001zzzzz: \<x19,x20> のペアを `[sp-#Z*8]!` に保存、事前インデックスされたオフセット >= -248 |
|`save_fplr`|        01zzzzzz: \<x29,lr> のペアを `[sp+#Z*8]` に保存、オフセット \<= 504。 |
|`save_fplr_x`|        10zzzzzz: \<x29,lr> のペアを `[sp-(#Z+1)*8]!` に保存、事前インデックスされたオフセット >= -512 |
|`alloc_m`|        11000xxx'xxxxxxxx: サイズ \< 16k (2^11 * 16) の大きいスタックを割り当てます。 |
|`save_regp`|        110010xx'xxzzzzzz: x(19+#X) ペアを `[sp+#Z*8]` に保存、オフセット \<= 504 |
|`save_regp_x`|        110011xx'xxzzzzzz: ペア x(19+#X) を `[sp-(#Z+1)*8]!` に保存、事前インデックスされたオフセット >= -512 |
|`save_reg`|        110100xx'xxzzzzzz: reg x(19+#X) を `[sp+#Z*8]` に保存、オフセット \<= 504 |
|`save_reg_x`|        1101010x'xxxzzzzz: reg x(19+#X) を `[sp-(#Z+1)*8]!` に保存、事前インデックスされたオフセット >= -256 |
|`save_lrpair`|         1101011x'xxzzzzzz: ペア \<x(19+2*#X),lr> を `[sp+#Z*8]` に保存、オフセット \<= 504 |
|`save_fregp`|        1101100x'xxzzzzzz: ペア d(8+#X) を `[sp+#Z*8]` に保存、オフセット \<= 504 |
|`save_fregp_x`|        1101101x'xxzzzzzz: ペア d(8+#X) を `[sp-(#Z+1)*8]!` に保存、事前インデックスされたオフセット >= -512 |
|`save_freg`|        1101110x'xxzzzzzz: reg d(8+#X) を `[sp+#Z*8]` に保存、オフセット \<= 504 |
|`save_freg_x`|        11011110'xxxzzzzz: reg d(8+#X) を `[sp-(#Z+1)*8]!` に保存、事前インデックスされたオフセット >= -256 |
|`alloc_l`|         11100000'xxxxxxxx'xxxxxxxx'xxxxxxxx: サイズ \< 256M (2^24 *16) の大きいスタックを割り当てます |
|`set_fp`|        11100001: x29: を `mov x29,sp` とセットアップします |
|`add_fp`|        11100010'xxxxxxxx: x29 を `add x29,sp,#x*8` とセットアップします |
|`nop`|            11100011: アンワインド演算は必要ありません。 |
|`end`|            11100100: アンワインド コードの終わりです。 エピローグの ret を意味します。 |
|`end_c`|        11100101: 現在のチェーン スコープのアンワインド コードの終わりです。 |
|`save_next`|        11100110: 次の非揮発性 Int または FP レジスタ ペアを保存します。 |
| |            11100111: 予約済み |
| |              11101xxx: asm ルーチンでのみ生成される以下のカスタム スタック ケース用に予約 |
| |              11101000:MSFT_OP_TRAP_FRAME のカスタム スタック |
| |              11101001:MSFT_OP_MACHINE_FRAME のカスタム スタック |
| |              11101010:MSFT_OP_CONTEXT のカスタム スタック |
| |              11101100:MSFT_OP_CLEAR_UNWOUND_TO_CALL のカスタム スタック |
| |              1111xxxx: 予約済み |

複数のバイトをカバーする大きな値を持つ命令では、最上位ビットが最初に格納されます。 この設計により、コードの最初のバイトだけを検索することで、アンワインド コードの合計サイズをバイト単位で見つけられるようになります。 各アンワインド コードは、プロローグまたはエピローグ内の命令に厳密にマップされているため、プロローグまたはエピローグのサイズを計算できます。 アンワインド コードをシーケンスの最初から最後まで調べて、ルックアップ テーブルまたは同様のデバイスを使用して対応するオペコードの長さを特定できます。

事後インデックスされたオフセット アドレス指定はプロローグ内では許可されていません。 すべてのオフセット範囲 (#Z) は、`save_r19r20_x` を除く STP/STR アドレス指定のエンコーディングと一致します。この場合は、すべての保存領域に対して 248 で十分です (10 個の Int レジスタ + 8 個の FP レジスタ + 8 個の入力レジスタ)。

`save_next` は、Int または FP 揮発性レジスタ ペアの保存に従う必要があります(`save_regp`、`save_regp_x`、`save_fregp`、`save_fregp_x`、`save_r19r20_x`、または別の `save_next`)。 これは次のレジスタ ペアを "拡大" 順で次の 16 バイトスロットに保存します。 `save_next` は、最後の Int レジスタ ペアを表す `save-next` に続く場合、最初の FP レジスタ ペアを参照します。

通常のリターン命令とジャンプ命令のサイズは同じであるため、末尾呼び出しのシナリオ用の別個の `end` アンワインド コードは必要ありません。

`end_c` は、連続していない関数フラグメントを最適化のために処理するように設計されています。 現在のスコープ内のアンワインド コードの末尾を示す `end_c` の後に、実際の `end` で終了する別の一連のアンワインド コードが続く必要があります。 `end_c` と `end` 間のアンワインド コードは、親リージョン ("ファントム" プロローグ) のプロローグ操作を表します。  詳細と例については、以下のセクションで説明します。

### <a name="packed-unwind-data"></a>パックされたアンワインド データ

関数のプロローグおよびエピローグが下に示す標準形式に従っている場合、パックされたアンワインド データを使用できます。 これにより .xdata レコードがまったく必要なくなり、アンワインド データの提供に必要なコストが大幅に削減されます。 標準のプロローグとエピローグは、単純な関数の一般的な要件を満たすように設計されています。例外ハンドラーを必要とせず、セットアップと破棄操作を標準の順序で実行するというものです。

パックされたアンワインド データを含む .pdata レコードの形式は、次のようになります。

![パックされたアンワインド データを含む .pdata レコード](media/arm64-exception-handling-packed-unwind-data.png "パックされたアンワインド データを含む .pdata レコード")

フィールドは次のとおりです。

- **Function Start RVA** は、関数の開始の 32 ビット の RVA です。
- **Flag** は、前述のように 2 ビットのフィールドであり、次の意味があります。
  - 00 = パックされたアンワインド データを使用しません。残りのビットは .xdata レコードをポイントします
  - 01 = スコープの先頭と末尾で 1 つのプロローグとエピローグで使用される、パックされたアンワインド データ
  - 10 = プロローグとエピローグのないコードに使用される、パックされたアンワインド データ。 分離された関数セグメントを記述する場合に便利です
  - 11 = 予約済み。
- **Function Length** は、関数全体の長さを 4 で除算してバイト単位で示す 11 ビット フィールドです。 関数が 8K より大きい場合、フル .xdata レコードを代わりに使用する必要があります。
- **Frame Size** は、この関数に割り当てられたスタックのバイト数を 16 で除算した値を示す 9 ビット フィールドです。 (8k-16) バイトを超えるスタックを割り当てる関数は、フル .xdata レコードを使用する必要があります。 ローカル変数領域、出力パラメーター領域、呼び出し先保存 Int および FP 領域、およびホーム パラメーター領域が含まれますが、動的割り当て領域は除外されます。
- **CR** は、フレーム チェーンおよびリターン リンクをセットアップするための追加の命令が関数に含まれているかどうかを示す 2 ビット フラグです。
  - 00 = 非チェーン関数、\<x29,lr> のペアはスタックに保存されません。
  - 01 = 非チェーン関数、\<lr> はスタックに保存されます
  - 10 = 予約済み。
  - 11 = チェーン関数、ストア/ロード ペア命令がプロローグ/エピローグ \<x29,lr> で使用されます
- **H** は、関数が、整数パラメーター レジスタ (x0-x7) を関数の先頭に格納することによって、それらを元に戻すかどうかを示す 1 ビット フラグです。 (0 = レジスタを元に戻しません、1 = レジスタを元に戻します)。
- **RegI** は、標準スタックの場所に保存された非揮発性 INT レジスタ (x19-x28) の数を示す 4 ビット フィールドです。
- **RegF** は、標準スタックの場所に保存された非揮発性 FP レジスタ (d8-d15) の数を示す 3 ビット フィールドです。 (RegF=0: FP レジスタは保存されません。RegF>0:RegF+1 FP レジスタが保存されます)。 パックされたアンワインド データは、1 つの FP レジスタだけを保存する関数には使用できません。

上記のセクションのカテゴリ 1、2 (送信パラメーター領域なし)、3 および 4 に分類される標準プロローグは、パックされたアンワインド形式で表すことができます。  標準関数のエピローグは同様の形式に従いますが、**H** が影響を及ぼさないこと、`set_fp` 命令が省略されること、および手順の順序と各手順の命令が、エピローグ内で反転されている点が異なります。 パックされた .xdata のアルゴリズムは、次の表に記載されている手順に従います。

手順 0:各領域のサイズを事前に計算します。

手順 1: Int の呼び出し先保存レジスタを保存します。

手順 2: この手順は、前半のセクションの種類 4 に固有です。 lr は、Int 領域の最後に保存されます。

手順 3: PF の呼び出し先保存レジスタを保存します。

手順 4: ホーム パラメーター領域に入力引数を保存します。

手順 5: 残りのスタックを割り当てます。これには、ローカル領域、\<x29,lr> のペア、および出力パラメーター領域が含まれます。 5a は標準の種類 1 に対応しています。 5b と5c は標準の種類 2 に対応しています。 5d と 5e は、種類 3 と種類 4 の両方を対象としています。

手順番号|フラグの値|命令の数|オペコード|アンワインド コード
-|-|-|-|-
0|||`#intsz = RegI * 8;`<br/>`if (CR==01) #intsz += 8; // lr`<br/>`#fpsz = RegF * 8;`<br/>`if(RegF) #fpsz += 8;`<br/>`#savsz=((#intsz+#fpsz+8*8*H)+0xf)&~0xf)`<br/>`#locsz = #famsz - #savsz`|
1|0 < **RegI** <= 10|RegI / 2 + **RegI** % 2|`stp x19,x20,[sp,#savsz]!`<br/>`stp x21,x22,[sp,#16]`<br/>`...`|`save_regp_x`<br/>`save_regp`<br/>`...`
2|**CR**==01*|1|`str lr,[sp,#(intsz-8)]`\*|`save_reg`
3|0 < **RegF** <=7|(RegF + 1) / 2 +<br/>(RegF + 1) % 2)|`stp d8,d9,[sp,#intsz]`\*\*<br/>`stp d10,d11,[sp,#(intsz+16)]`<br/>`...`<br/>`str d(8+RegF),[sp,#(intsz+fpsz-8)]`|`save_fregp`<br/>`...`<br/>`save_freg`
4|**H** == 1|4|`stp x0,x1,[sp,#(intsz+fpsz)]`<br/>`stp x2,x3,[sp,#(intsz+fpsz+16)]`<br/>`stp x4,x5,[sp,#(intsz+fpsz+32)]`<br/>`stp x6,x7,[sp,#(intsz+fpsz+48)]`|`nop`<br/>`nop`<br/>`nop`<br/>`nop`
5a|**CR** == 11 && #locsz<br/> <= 512|2|`stp x29,lr,[sp,#-locsz]!`<br/>`mov x29,sp`\*\*\*|`save_fplr_x`<br/>`set_fp`
5b|**CR** == 11 &&<br/>512 < #locsz <= 4080|3|`sub sp,sp,#locsz`<br/>`stp x29,lr,[sp,0]`<br/>`add x29,sp,0`|`alloc_m`<br/>`save_fplr`<br/>`set_fp`
5c|**CR** == 11 && #locsz > 4080|4|`sub sp,sp,4080`<br/>`sub sp,sp,#(locsz-4080)`<br/>`stp x29,lr,[sp,0]`<br/>`add x29,sp,0`|`alloc_m`<br/>`alloc_s`/`alloc_m`<br/>`save_fplr`<br/>`set_fp`
5d|(**CR** == 00 \|\| **CR**==01) &&<br/>#locsz <= 4080|1|`sub sp,sp,#locsz`|`alloc_s`/`alloc_m`
5e|(**CR** == 00 \|\| **CR**==01) &&<br/>#locsz > 4080|2|`sub sp,sp,4080`<br/>`sub sp,sp,#(locsz-4080)`|`alloc_m`<br/>`alloc_s`/`alloc_m`

\* **CR** == 01 で **RegI** が奇数の場合は、手順 2 と手順 1 の最後の save_rep が 1 つの save_regp にマージされます。

\*\* **RegI** == **CR** == 0、および **RegF** != 0 の場合、浮動小数点の最初の stp は前置デクリメントを行います。

\*\*\* `mov x29,sp` に対応する命令はエピローグに存在しません。 関数で x29 から sp を復元する必要がある場合、パックされたアンワインド データを使用できません。

### <a name="unwinding-partial-prologs-and-epilogs"></a>部分的なプロローグおよびエピローグのアンワインド

アンワインドが行われる状況としては、プロローグやすべてのエピローグではなく、関数の本体で例外または呼び出しが発生した場合が最も一般的です。 このような状況では、アンワインドは単純です。アンワインダーは、インデックス 0 から始まるアンワインド配列内のコードの実行を開始し、終了オペコードが検出されるまで続行します。

プロローグまたはエピローグの実行中に例外または割り込みが発生した場合、適切にアンワインドするのはより困難です。 このような状況では、スタック フレームは部分的にのみ構築されます。 問題は、何が行われたかを正確に判断し、正しく元に戻すことです。

たとえば、次のプロローグとエピローグ シーケンスを考えてみます。

```asm
0000:    stp    x29,lr,[sp,#-256]!          // save_fplr_x  256 (pre-indexed store)
0004:    stp    d8,d9,[sp,#224]             // save_fregp 0, 224
0008:    stp    x19,x20,[sp,#240]           // save_regp 0, 240
000c:    mov    x29,sp                      // set_fp
         ...
0100:    mov    sp,x29                      // set_fp
0104:    ldp    x19,x20,[sp,#240]           // save_regp 0, 240
0108:    ldp    d8,d9,[sp,224]              // save_fregp 0, 224
010c:    ldp    x29,lr,[sp],#256            // save_fplr_x  256 (post-indexed load)
0110:    ret    lr                          // end
```

各オペコードの横には、この演算を記述する適切なアンワインド コードがあります。 プロローグの一連のアンワインド コードは、エピローグのアンワインド コードの正確なミラー イメージになっていることが確認できます (エピローグの最後の命令はカウントされていません)。 これは一般的な状況であり、このため、プロローグのアンワインド コードがプロローグの実行順と逆の順序で格納されることが常に想定されます。

したがって、プロローグとエピローグの両方で、共通のアンワインド コードのセットが残されています。

`set_fp`, `save_regp 0,240`, `save_fregp,0,224`, `save_fplr_x_256`, `end`

エピローグは通常の順序であるため、単純です。 (関数内のオフセット 0x100 から開始する) エピローグ内のオフセット 0 から開始すると、クリーンアップがまだ行われていないため、完全なアンワインド シーケンスが実行されることが予想されます。 (エピローグのオフセット 2 で) 命令が 1 つある場合、最初のアンワインド コードをスキップして正常にアンワインドできます。 この状況を一般化し、オペコードとアンワインド コードの間に 1:1 のマッピングがあることを想定できます。 次に、エピローグで命令 *n* からアンワインドを開始するには、最初の *n* 個のアンワインド コードをスキップし、そこから実行を開始する必要があります。

これにより、(逆になることを除き) 同じようなロジックがプロローグに対して機能することがわかります。 プロローグ内のオフセット 0 からアンワインドを開始する場合は、何も実行しません。 1 つの命令があるオフセット 2 からアンワインドする場合は、末尾から 1 つのアンワインド コードのアンワインド シーケンスの実行を開始する必要があります。 (コードが逆の順序で格納されていることに注意してください)。ここでも一般化が可能です。プロローグ内の命令 n からアンワインドを開始する場合、コードのリストの末尾から n 番目のアンワインド コードの実行を開始する必要があります。

プロローグ コードとエピローグ コードはいつも正確に一致するとは限りません。 このため、アンワインド配列にいくつかのコード シーケンスが含まれていることが必要な場合もあります。 コードの処理を開始する位置のオフセットを特定するには、次のロジックを使用します。

1. 関数本体内からのアンワインドの場合、インデックス 0 でアンワインド コードの実行を開始し、"終了" オペコードに到達するまで続行します。

1. エピローグ内からのアンワインドの場合、エピローグ スコープにより開始ポイントとして提供されるエピローグ固有の開始インデックスを使用します。 エピローグの開始から問題の PC までのバイト数を計算します。 次に、アンワインド コードを前方に進め、既に実行済みの命令がすべて含まれるまでアンワインド コードをスキップします。 その後、その時点から実行します。

1. プロローグ内からアンワインドする場合は、開始点としてインデックス 0 を使用します。 シーケンスからプロローグ コードの長さを計算し、プロローグの末尾から問題の PC までのバイト数を計算します。 次に、アンワインド コードを前方に進め、まだ実行されていない命令がすべて含まれるまでアンワインド コードをスキップします。 その後、その時点から実行します。

これらのルールは、プロローグのアンワインド コードが常に配列の最初に存在する必要があることを意味します。 また、これらは本体内からのアンワインドという一般的な場合のアンワインドに使用されるコードでもあります。 すべてのエピローグ固有のコード シーケンスは、直後に続く必要があります。

### <a name="function-fragments"></a>関数フラグメント

コードの最適化などの理由から、関数は分離されたフラグメント (リージョンとも呼ばれます) に分割することが望ましい場合があります。 分割すると、結果としての各関数フラグメントには、個別の .pdata (および場合によっては .xdata) レコードが必要となります。

独自のプロローグを持つ分離された各セカンダリ フラグメントでは、そのプロローグ内でスタック調整が行われないことが想定されます。 セカンダリ リージョンに必要なすべてのスタック領域は、その親リージョン (またはホスト リージョンとも呼ばれます) によって事前に割り当てられている必要があります。 これにより、スタック ポインター操作が関数の元のプロローグ内で厳密に維持されます。

関数フラグメントの典型的な例として "コードの分離" があり、これにより、コンパイラによってコードのリージョンがそのホスト関数の外に移動されることがあります。 コードの分離によって発生する可能性のある異常なケースが 3 つあります。

#### <a name="example"></a>例

- (リージョン 1: 開始)

    ```asm
        stp     x29,lr,[sp,#-256]!      // save_fplr_x  256 (pre-indexed store)
        stp     x19,x20,[sp,#240]       // save_regp 0, 240
        mov     x29,sp                  // set_fp
        ...
    ```

- (リージョン 1: 終了)

- (リージョン 3: 開始)

    ```asm
        ...
    ```

- (リージョン 3: 終了)

- (リージョン 2: 開始)

    ```asm
        ...
        mov     sp,x29                  // set_fp
        ldp     x19,x20,[sp,#240]       // save_regp 0, 240
        ldp     x29,lr,[sp],#256        // save_fplr_x  256 (post-indexed load)
        ret     lr                      // end
    ```

- (リージョン 2: 終了)

1. プロローグのみ (リージョン 1: すべてのエピローグは分離されたリージョンにあります):

   プロローグだけを記述する必要があります。 これはコンパクトな .pdata 形式では表現できません。 完全な .xdata の場合は、エピローグ カウントを 0 に設定して表すことができます。 上の例のリージョン 1 を参照してください。

   アンワインド コード: `set_fp`、`save_regp 0,240`、`save_fplr_x_256`、`end`。

1. エピローグのみ (リージョン 2: プロローグはホスト リージョンにあります)

   制御がこのリージョンに移るまでに、すべてのプロローグ コードが実行されていることが想定されます。 部分アンワインドが、通常の関数と同じようにエピローグで発生する可能性があります。 この種類のリージョンをコンパクトな .pdata で表すことはできません。 完全な .xdata レコードでは、`end_c` と `end` のアンワインド コード ペアで囲まれた、"ファントム" プロローグを使用してエンコードすることができます。  先頭の `end_c` は、プロローグのサイズが 0 であることを示します。 単一のエピローグのエピローグ開始インデックスは、`set_fp` を指しています。

   リージョン 2 のアンワインド コード: `end_c`、`set_fp`、`save_regp 0,240`、`save_fplr_x_256`、`end`。

1. プロローグもエピローグもない (リージョン 3: プロローグおよびすべてのエピローグが他のフラグメントに含まれている):

   Flag = 10 に設定して、コンパクトな .pdata 形式を適用することができます。 完全な .xdata レコードでは、Epilog Count = 1 です。 アンワインド コードは上記のリージョン 2 のコードと同じですが、Epilog Start Index も `end_c` を指しています。 このコードのリージョンでは部分アンワインドは発生しません。

関数フラグメントのもう 1 つの複雑なケースとして、"シュリンク ラッピング" があります。 コンパイラによって、関数エントリのプロローグに含まれなくなるまで、一部の呼び出し先保存レジスタの保存が遅延される場合があります。

- (リージョン 1: 開始)

    ```asm
        stp     x29,lr,[sp,#-256]!      // save_fplr_x  256 (pre-indexed store)
        stp     x19,x20,[sp,#240]       // save_regp 0, 240
        mov     x29,sp                  // set_fp
        ...
    ```

- (リージョン 2: 開始)

    ```asm
        stp     x21,x22,[sp,#224]       // save_regp 2, 224
        ...
        ldp     x21,x22,[sp,#224]       // save_regp 2, 224
    ```

- (リージョン 2: 終了)

    ```asm
        ...
        mov     sp,x29                  // set_fp
        ldp     x19,x20,[sp,#240]       // save_regp 0, 240
        ldp     x29,lr,[sp],#256        // save_fplr_x  256 (post-indexed load)
        ret     lr                      // end
    ```

- (リージョン 1: 終了)

リージョン 1 のプロローグには、スタック領域が事前に割り当てられています。 リージョン 2 は、ホスト関数の外に移されても、同じアンワインド コードを持つことがわかります。

リージョン 1: `set_fp`、`save_regp 0,240`、`save_fplr_x_256`、`end` で、Epilog Start Index は通常どおりに `set_fp` を指します。

リージョン 2: `save_regp 2, 224`、`end_c`、`set_fp`、`save_regp 0,240`、`save_fplr_x_256`、`end`。 Epilog Start Index は、最初のアンワインド コード `save_regp 2, 224` を指します。

### <a name="large-functions"></a>大きな関数

フラグメントを使用して、.xdata ヘッダーのビット フィールドによって設定される 1M 制限を超える関数を記述できます。 このような非常に大きな関数を記述するには、1M より小さいフラグメントに分割する必要があります。 各フラグメントは、エピローグが複数の部分に分割されないように調整する必要があります。

関数の最初のフラグメントにのみプロローグが含まれます。その他のすべてのフラグメントは、プロローグが含まれていないとマークされます。 存在するエピローグの数に応じて、各フラグメントに 0 個以上のエピローグが含まれます。 フラグメント内の各エピローグ スコープでは、関数の開始からではなく、フラグメントの開始からの相対値で開始オフセットが指定されることに注意してください。

フラグメントにプロローグとエピローグが含まれていない場合でも、関数の本体内からのアンワインド方法を記述するための固有の .pdata (および場合によっては .xdata) レコードが必要です。

## <a name="examples"></a>使用例

### <a name="example-1-frame-chained-compact-form"></a>例 1: フレームチェーン、コンパクト形式

```asm
|Foo|     PROC
|$LN19|
    str     x19,[sp,#-0x10]!        // save_reg_x
    sub     sp,sp,#0x810            // alloc_m
    stp     fp,lr,[sp]              // save_fplr
    mov     fp,sp                   // set_fp
                                    //  end of prolog
    ...

|$pdata$Foo|
    DCD     imagerel     |$LN19|
    DCD     0x416101ed
    ;Flags[SingleProEpi] functionLength[492] RegF[0] RegI[1] H[0] frameChainReturn[Chained] frameSize[2080]
```

### <a name="example-2-frame-chained-full-form-with-mirror-prolog--epilog"></a>例 2:フレームチェーン、ミラー プロローグとエピローグを使用した完全な形式

```asm
|Bar|     PROC
|$LN19|
    stp     x19,x20,[sp,#-0x10]!    // save_regp_x
    stp     fp,lr,[sp,#-0x90]!      // save_fplr_x
    mov     fp,sp                   // set_fp
                                    // end of prolog
    ...
                                    // begin of epilog, a mirror sequence of Prolog
    mov     sp,fp
    ldp     fp,lr,[sp],#0x90
    ldp     x19,x20,[sp],#0x10
    ret     lr

|$pdata$Bar|
    DCD     imagerel     |$LN19|
    DCD     imagerel     |$unwind$cse2|
|$unwind$Bar|
    DCD     0x1040003d
    DCD     0x1000038
    DCD     0xe42291e1
    DCD     0xe42291e1
    ;Code Words[2], Epilog Count[1], E[0], X[0], Function Length[6660]
    ;Epilog Start Index[0], Epilog Start Offset[56]
    ;set_fp
    ;save_fplr_x
    ;save_r19r20_x
    ;end
```

Epilog Start Index [0] は、プロローグ アンワインド コードの同じシーケンスを指します。

### <a name="example-3-variadic-unchained-function"></a>例 3:可変個引数の非チェーン関数

```asm
|Delegate| PROC
|$LN4|
    sub     sp,sp,#0x50
    stp     x19,lr,[sp]
    stp     x0,x1,[sp,#0x10]        // save incoming register to home area
    stp     x2,x3,[sp,#0x20]        // ...
    stp     x4,x5,[sp,#0x30]
    stp     x6,x7,[sp,#0x40]        // end of prolog
    ...
    ldp     x19,lr,[sp]             // beginning of epilog
    add     sp,sp,#0x50
    ret     lr

    AREA    |.pdata|, PDATA
|$pdata$Delegate|
    DCD     imagerel |$LN4|
    DCD     imagerel |$unwind$Delegate|

    AREA    |.xdata|, DATA
|$unwind$Delegate|
    DCD     0x18400012
    DCD     0x200000f
    DCD     0xe3e3e3e3
    DCD     0xe40500d6
    DCD     0xe40500d6
    ;Code Words[3], Epilog Count[1], E[0], X[0], Function Length[18]
    ;Epilog Start Index[4], Epilog Start Offset[15]
    ;nop        // nop for saving in home area
    ;nop        // ditto
    ;nop        // ditto
    ;nop        // ditto
    ;save_lrpair
    ;alloc_s
    ;end
```

Epilog Start Index [4] は、プロローグ アンワインド コードの中間を指します (アンワインド配列を部分的に再利用します)。

## <a name="see-also"></a>関連項目

[ARM64 ABI 規則の概要](arm64-windows-abi-conventions.md)<br/>
[ARM 例外処理](arm-exception-handling.md)
